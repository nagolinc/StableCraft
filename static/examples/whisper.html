<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js vr - teleport</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - teleport
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';

        import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        let camera, scene, raycaster, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        let room, marker, floor, baseReferenceSpace;

        let INTERSECTION;
        const tempMatrix = new THREE.Matrix4();

        init();
        animate();

        function init() {

            scene = new THREE.Scene();
            const bg_col=0x505050
            scene.background = new THREE.Color(bg_col);

            const near=10
            const far=30
            scene.fog = new THREE.Fog(bg_col, near, far);



            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 30);
            camera.position.set(0, 1, 3);

            const roomSize=100

            room = new THREE.LineSegments(
                new BoxLineGeometry(6*roomSize, 6, 6*roomSize, 10*roomSize, 10, 10*roomSize).translate(0, 3, 0),
                new THREE.LineBasicMaterial({ color: 0x808080 })
            );
            scene.add(room);

            scene.add(new THREE.HemisphereLight(0x606060, 0x404040));

            const light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);

            marker = new THREE.Mesh(
                new THREE.CircleGeometry(0.25, 32).rotateX(- Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x808080 })
            );
            scene.add(marker);

            floor = new THREE.Mesh(
                new THREE.PlaneGeometry(4.8*roomSize, 4.8*roomSize, 2, 2).rotateX(- Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x808080, transparent: true, opacity: 0.25 })
            );
            scene.add(floor);
            floor.scale.set(2,2,2);

            raycaster = new THREE.Raycaster();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.xr.addEventListener('sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace());
            renderer.xr.enabled = true;

            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // controllers

            function onSelectStart() {

                this.userData.isSelecting = true;

            }

            function onSelectEnd() {

                this.userData.isSelecting = false;

                if (INTERSECTION) {

                    const offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };
                    const offsetRotation = new THREE.Quaternion();
                    const transform = new XRRigidTransform(offsetPosition, offsetRotation);
                    const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace(transform);

                    renderer.xr.setReferenceSpace(teleportSpaceOffset);

                }

            }

            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('connected', function (event) {

                this.add(buildController(event.data));

            });
            controller1.addEventListener('disconnected', function () {

                this.remove(this.children[0]);

            });
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('connected', function (event) {

                this.add(buildController(event.data));

            });
            controller2.addEventListener('disconnected', function () {

                this.remove(this.children[0]);

            });
            scene.add(controller2);

            // The XRControllerModelFactory will automatically fetch controller models
            // that match what the user is holding as closely as possible. The models
            // should be attached to the object returned from getControllerGrip in
            // order to match the orientation of the held device.

            const controllerModelFactory = new XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function buildController(data) {

            let geometry, material;

            switch (data.targetRayMode) {

                case 'tracked-pointer':

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

                    material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

                    return new THREE.Line(geometry, material);

                case 'gaze':

                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
                    material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
                    return new THREE.Mesh(geometry, material);

            }

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function animate() {

            renderer.setAnimationLoop(render);

        }

        function render() {

            INTERSECTION = undefined;

            if (controller1.userData.isSelecting === true) {

                tempMatrix.identity().extractRotation(controller1.matrixWorld);

                raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObjects([floor]);

                if (intersects.length > 0) {

                    INTERSECTION = intersects[0].point;

                }

            } else if (controller2.userData.isSelecting === true) {

                tempMatrix.identity().extractRotation(controller2.matrixWorld);

                raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObjects([floor]);

                if (intersects.length > 0) {

                    INTERSECTION = intersects[0].point;

                }

            }

            if (INTERSECTION) marker.position.copy(INTERSECTION);

            marker.visible = INTERSECTION !== undefined;

            renderer.render(scene, camera);

            //poll for controllers
            dollyMove();

        }

        //game pad stuff
        const prevGamePads = new Map();
        let mode = "NONE"


        function dollyMove() {
            var handedness = "unknown";

            //determine if we are in an xr session
            const session = renderer.xr.getSession();
            let i = 0;

            if (session) {

                //a check to prevent console errors if only one input source
                if (isIterable(session.inputSources)) {
                    for (const source of session.inputSources) {
                        if (source && source.handedness) {
                            handedness = source.handedness; //left or right controllers
                        }
                        if (!source.gamepad) continue;
                        const controller = renderer.xr.getController(i++);
                        const old = prevGamePads.get(source);
                        const data = {
                            handedness: handedness,
                            buttons: source.gamepad.buttons.map((b) => b.value),
                            axes: source.gamepad.axes.slice(0)
                        };

                        //console.log(data)
                        /*for (var button_id in data.buttons) {
                            if (data.buttons[button_id]) {
                                console.log("button", button_id)
                            }
                        }*/


                        //button 4 (right A) will start recording
                        if (data.handedness == "right" && data.buttons[4] && mode == "NONE") {
                            console.log("start recording")
                            startRecording()
                            mode = "RECORDING"
                        } else {
                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "RECORDING") {
                                console.log("stop recording")
                                stopRecording()
                                mode = "NONE"
                            }

                        }


                        ///???? = B
                        //4 == A
                        //3 = ?grip
                        //2=touchpad
                        //1 = joystick
                        //0 = trigger







                        ///store this frames data to compate with in the next frame
                        prevGamePads.set(source, data);
                    }
                }
            }
        }

        function isIterable(obj) {  //function to check if object is iterable
            // checks for null and undefined
            if (obj == null) {
                return false;
            }
            return typeof obj[Symbol.iterator] === "function";
        }


        var mediaRecorder
        var recordedChunks


        var onFail = function (e) {
            console.log('Rejected!', e);
        };

        var onSuccess = function (stream) {
            recordedChunks = [];

            var options = { mimeType: 'audio/webm' };
            mediaRecorder = new MediaRecorder(stream, options);
            mediaRecorder.ondataavailable = handleDataAvailable;
            mediaRecorder.start();
            function handleDataAvailable(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                } else {
                    // ...
                }
            }
        }

        window.URL = window.URL || window.webkitURL;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

        var recorder;
        var audio = document.querySelector('audio');

        
        let nextCubePosition;
        let nextCubeRotation;
        let placeholderCube;

        function startRecording() {
            if (navigator.getUserMedia) {
                navigator.getUserMedia({ audio: true }, onSuccess, onFail);
            } else {
                console.log('navigator.getUserMedia not present');
            }




            //camera position?
            const position = new THREE.Vector3();
            const rotation = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            

            // the following line extracts the position, rotation and scale in world space
            camera.matrixWorld.decompose( position, rotation, scale );

            const euler = new THREE.Euler();
            euler.setFromQuaternion ( rotation,"YZX")

            console.log("camera mw",camera.matrixWorld,position,rotation,scale,euler)

            //const camera_direction=camera.getWorldDirection()
            //let r=Math.atan2(camera_direction.x,camera_direction.z)
            //console.log("camera direction",camera_direction,r)
            let r=euler.y


            nextCubePosition = new THREE.Vector3().copy(position);
            nextCubePosition.y=1
            nextCubePosition.x-=2*Math.sin(r)
            nextCubePosition.z-=2*Math.cos(r)

            

            nextCubeRotation = r
            console.log("rotation",nextCubeRotation)

            placeholderCube=addPlaceholder(nextCubePosition,nextCubeRotation,"#00ff00");


        }

        async function play(nextCubePosition) {
            var superBuffer = new Blob(recordedChunks);
            audio.src =
                window.URL.createObjectURL(superBuffer);

            let placeholder=addPlaceholder(nextCubePosition,nextCubeRotation,"#aaaaaa");
            console.log("added placeholder")

            //send blob to server
            let fd = new FormData();
            fd.append("audio_data", superBuffer);

            //fetch url from /tts endpoint
            let response = await fetch("/putAudio", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()

            console.log(data)

            add3dImage(data,nextCubePosition,nextCubeRotation)
            scene.remove(placeholder)

        }

        function stopRecording() {

            if(!mediaRecorder) return

            mediaRecorder.stop();

            scene.remove(placeholderCube)
            
            function doPlay(){
                play(nextCubePosition)
            }
            setTimeout(doPlay, 0.1)

        }


        function add3dImage(data,position,rotation) {
            let imgPath = data[1].substring(1)
            let dPath = data[2].substring(1)
            const textureLoader = new THREE.TextureLoader();
            const colorMap = textureLoader.load(imgPath);
            const displacementMap = textureLoader.load(dPath);

            let material = new THREE.MeshStandardMaterial({
                map: colorMap,
                displacementMap: displacementMap,
                displacementScale: 1.0,
                displacementBias: -0.5, // from original model
                side: THREE.DoubleSide
            });



            //let geometry = new THREE.BoxGeometry(1, 1, 1, 100, 100, 100);
            let geometry = new THREE.PlaneGeometry(1, 1, 100, 100);
            let mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            //mesh.rotation.y = rotation - Math.PI / 2;
            mesh.rotation.y = rotation ;
            mesh.position.copy(position);
        }

        function addPlaceholder(position,rotation,color) {            
            let material = new THREE.MeshStandardMaterial({
                color:color,
                side: THREE.DoubleSide
            });

            let geometry = new THREE.BoxGeometry(1, 1, 1, 100, 100, 100);
            let mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            mesh.position.copy(position);
            mesh.rotation.y = rotation - Math.PI;

            return mesh
        }



    </script>

    <audio controls></audio>


</body>

</html>