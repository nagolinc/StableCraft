<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js vr - teleport</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>

<body>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';

        import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TWEEN } from 'three/addons/libs/tween.module.min.js'


        let audioReady = false
        let audioTodo = []
        let AUDIO_REF_DIST = 1.0

        let camera, scene, raycaster, renderer;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        let room, marker, floor, baseReferenceSpace;

        let INTERSECTION;
        let TARGET_OBJECT;
        const tempMatrix = new THREE.Matrix4();

        //save load logic
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        let saveName
        if (urlParams.get("savePath")) {
            saveName = urlParams.get("saveName")
        } else {
            saveName = "world0"
        }
        let savePath = saveName + ".json"


        let baseSize = 512
        if (urlParams.get("modelSize768")) {
            baseSize = 768
        }

        let WORLD = saveName
        let USER = "user0"//todo fixme

        let saveData = {
            "objects": []
        }

        if (savePath != "NONE") {
            //doLoad(savePath)
        }


        //store objects (so we can do interactions)
        let allMeshes = []
        let allCaptions = []
        var loader = new FontLoader();
        let gridToMeshes = {}
        let gridLoaded = {}
        let gridSize = 8
        let bgGenRange = 1
        let bgGenRange_floor = 2

        //floor
        let floorTiles = {}
        let floorTiles_list = []
        let terrainScale = 0.1
        let terrainScaleY = 5
        let playerHeight = 1.5
        let seaLevel = 0.5
        const textureLoader = new THREE.TextureLoader();
        const floorNormals = textureLoader.load("./noise.png");


        let aspect_ratios = {
            0: "square",
            1: "portrait",
            2: "landscape"
        }
        let which_aspect_ratio = 1
        let aspect_ratio = "portrait"
        let num_aspect_ratios = 3

        //stuff

        let cameraOffsetPosition = new THREE.Vector3()
        let cameraOffsetRotation = new THREE.Quaternion()
        let rotationCounter = 0;

        //action modes
        let ACTION_MODES = {
            0: "",
            1: "create",
            2: "duplicate",
            3: "recreate",
            4: "delete",
            5: "aspect ratio",
            6: "object type",
            7: "audio",
            8: "resize",
            9: "move",

        }
        let ACTION_MODE_TO_INDEX = {}
        for (var i in ACTION_MODES) {
            ACTION_MODE_TO_INDEX[i] = i
        }

        let ACTION_MODE = 1//create
        let NUM_ACTION_MODES = 10

        //object type
        let OBJECT_TYPES = {
            0: "Object",
            1: "NPC",
            2: "Building",
            3: "Plant",
            4: "Tree",
            5: "Mob",
            6: "Boss",
            7: "Fish",
        }

        let CURRENT_OBJECT_TYPE = 1
        let NUM_OBJECT_TYPES = 8
        let OBJECT_TYPE = OBJECT_TYPES[CURRENT_OBJECT_TYPE]//"Object"

        let near = 5
        let far = 15

        init();
        animate();

        function init() {

            scene = new THREE.Scene();
            const bg_col = 0x505050
            scene.background = new THREE.Color(bg_col);

            scene.fog = new THREE.Fog(bg_col, near, far);



            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 30);
            camera.position.set(0, 1, 3);

            const roomSize = 100

            /*room = new THREE.LineSegments(
                new BoxLineGeometry(6 * roomSize, 6, 6 * roomSize, 10 * roomSize, 10, 10 * roomSize).translate(0, 3, 0),
                new THREE.LineBasicMaterial({ color: 0x808080 })
            );
            scene.add(room);*/

            scene.add(new THREE.HemisphereLight(0x606060, 0x404040));

            const light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);

            marker = new THREE.Mesh(
                new THREE.CircleGeometry(0.25, 32).rotateX(- Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x808080 })
            );
            scene.add(marker);

            /*floor = new THREE.Mesh(
                new THREE.PlaneGeometry(4.8 * roomSize, 4.8 * roomSize, 2, 2).rotateX(- Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x808080, transparent: true, opacity: 0.25 })
            );
            scene.add(floor);
            floor.scale.set(2, 2, 2);*/
            //generateFloorTiles(camera.position)
            updateWorld(camera.position)


            raycaster = new THREE.Raycaster();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.xr.addEventListener('sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace());
            renderer.xr.enabled = true;

            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // controllers

            function onSelectStart() {

                this.userData.isSelecting = true;

            }


            function onSelectEnd() {

                this.userData.isSelecting = false;

                if (TARGET_OBJECT) {
                    displayCaption(TARGET_OBJECT)
                } else if (INTERSECTION) {

                    /*const offsetPosition = { x: - INTERSECTION.x, y: - INTERSECTION.y, z: - INTERSECTION.z, w: 1 };
                    const offsetRotation = new THREE.Quaternion().copy(cameraOffsetRotation);
                    const transform = new XRRigidTransform(offsetPosition, offsetRotation);
                    const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace(transform);

                    cameraOffsetPosition.copy(offsetPosition)*/

                    let delta = new THREE.Vector3().copy(INTERSECTION)
                    delta.addScaledVector(camera.position, -1)
                    //delta.y = 0
                    delta.y += playerHeight
                    //cameraOffsetPosition.copy(INTERSECTION)
                    cameraOffsetPosition.add(delta)
                    console.log(camera.position, INTERSECTION)


                    let nullPosition = { x: 0, y: 0, z: 0, w: 1 };
                    let nullRotation = new THREE.Quaternion()
                    const offsetPosition = { x: - cameraOffsetPosition.x, y: - cameraOffsetPosition.y, z: - cameraOffsetPosition.z, w: 1 };
                    let offsetRotation = new THREE.Quaternion().copy(cameraOffsetRotation);
                    const turn = new THREE.Quaternion()
                    turn.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 4);


                    updateWorld(cameraOffsetPosition)


                    hideDistanceObjects(cameraOffsetPosition)


                    const transform = new XRRigidTransform(offsetPosition, nullRotation);
                    const doRotate = new XRRigidTransform(nullPosition, offsetRotation);
                    const t2 = baseReferenceSpace.getOffsetReferenceSpace(doRotate)
                    const t3 = t2.getOffsetReferenceSpace(transform);
                    renderer.xr.setReferenceSpace(t3);
                }

            }

            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('connected', function (event) {

                this.add(buildController(event.data));

            });
            controller1.addEventListener('disconnected', function () {

                this.remove(this.children[0]);

            });
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('connected', function (event) {

                this.add(buildController(event.data));

            });
            controller2.addEventListener('disconnected', function () {

                this.remove(this.children[0]);

            });
            scene.add(controller2);

            // The XRControllerModelFactory will automatically fetch controller models
            // that match what the user is holding as closely as possible. The models
            // should be attached to the object returned from getControllerGrip in
            // order to match the orientation of the held device.

            const controllerModelFactory = new XRControllerModelFactory();

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function buildController(data) {

            let geometry, material;

            switch (data.targetRayMode) {

                case 'tracked-pointer':

                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));


                    material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

                    return new THREE.Line(geometry, material);

                case 'gaze':

                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
                    material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
                    return new THREE.Mesh(geometry, material);

            }

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function animate() {

            renderer.setAnimationLoop(render);

        }

        function render(time) {

            //console.log("here",time)
            //TWEEN.update(time)

            INTERSECTION = undefined;

            if (controller1.userData.isSelecting === true) {

                tempMatrix.identity().extractRotation(controller1.matrixWorld);

                raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

                //check for intersects with meshs
                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                /*if (intersects_mesh.length > 0) {
                    //displayCaption(intersects_mesh[0].object)
                    TARGET_OBJECT = intersects_mesh[0].object
                } else {
                    //hideAllCaptions()
                    TARGET_OBJECT = null
                }*/
                //only do this for right hand
                TARGET_OBJECT = null


                //const intersects = raycaster.intersectObjects([floor]);
                const intersects = raycaster.intersectObjects(floorTiles_list);

                if (intersects.length > 0) {

                    INTERSECTION = intersects[0].point;

                }

            } else if (controller2.userData.isSelecting === true) {

                tempMatrix.identity().extractRotation(controller2.matrixWorld);

                raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

                //check for intersects with meshs
                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                if (intersects_mesh.length > 0) {
                    TARGET_OBJECT = intersects_mesh[0].object
                } else {
                    TARGET_OBJECT = null
                }

                //const intersects = raycaster.intersectObjects([floor]);
                const intersects = raycaster.intersectObjects(floorTiles_list);

                if (intersects.length > 0) {
                    INTERSECTION = intersects[0].point;
                }

            }

            if (INTERSECTION) marker.position.copy(INTERSECTION);

            marker.visible = INTERSECTION !== undefined;

            renderer.render(scene, camera);

            //poll for controllers
            dollyMove();


            TWEEN.update(time)

        }

        //game pad stuff
        const prevGamePads = new Map();
        let mode = "NONE"
        let lhs_mode = "NONE"
        //move object
        let controller_move_start
        let object_move_start
        let objectToMove
        let startingObjectScale
        let startingControllerDist


        function dollyMove() {
            var handedness = "unknown";

            //determine if we are in an xr session
            const session = renderer.xr.getSession();
            let i = 0;

            if (session) {

                //a check to prevent console errors if only one input source
                if (isIterable(session.inputSources)) {

                    if (!audioReady) {
                        getAudioReady();
                    }

                    //resize is updated every frame
                    //intermediate resize object
                    if (mode == "RESIZE_OBJECT") {

                        let endingControllerDist = controller1.position.clone().sub(controller2.position).length()
                        let endingObjectScale = startingObjectScale * endingControllerDist / startingControllerDist

                        console.log("foo", endingObjectScale)

                        objectToMove.scale.set(endingObjectScale, endingObjectScale, endingObjectScale)

                    }



                    for (const source of session.inputSources) {
                        if (source && source.handedness) {
                            handedness = source.handedness; //left or right controllers
                        }
                        if (!source.gamepad) continue;
                        let controller = renderer.xr.getController(i++);

                        //console.log(controller,controller1,controller2)
                        if (source.handedness == "left") {
                            controller = controller1
                        } else {
                            controller = controller2
                        }

                        const old = prevGamePads.get(source);
                        const data = {
                            handedness: handedness,
                            buttons: source.gamepad.buttons.map((b) => b.value),
                            axes: source.gamepad.axes.slice(0)
                        };

                        //console.log(data)
                        /*for (var button_id in data.buttons) {
                            if (data.buttons[button_id]) {
                                console.log("button", button_id)
                            }
                        }*/

                        //snap turn
                        //console.log(data.axes)
                        //axis [touchpad X, touchpad Y, joystick X, joystick Y]
                        if (mode == "NONE" && data.axes[2] > 0.75 && data.handedness == "right") {
                            console.log("start turning right")
                            mode = "SNAPTURN_RIGHT_" + data.handedness
                        }

                        if (mode == "NONE" && data.axes[2] < -0.75 && data.handedness == "right") {
                            console.log("starting left turn")
                            mode = "SNAPTURN_LEFT_" + data.handedness
                        }

                        if (mode == "SNAPTURN_RIGHT_" + data.handedness && data.axes[2] < 0.05 && data.handedness == "right") {
                            //do snapturn
                            console.log("turning right")
                            let turnAmount = Math.PI / 4
                            doSnapTurn(turnAmount)
                            mode = "NONE"
                        }

                        if (mode == "SNAPTURN_LEFT_" + data.handedness && data.axes[2] > -0.05 && data.handedness == "right") {
                            //do snapturn
                            console.log("turning left")
                            let turnAmount = -Math.PI / 4
                            doSnapTurn(turnAmount)
                            mode = "NONE"
                        }


                        //mode
                        //snap turn
                        //console.log(data.axes)
                        //axis [touchpad X, touchpad Y, joystick X, joystick Y]
                        if (mode == "NONE" && data.axes[2] > 0.75 && data.handedness == "left") {
                            console.log("change action mode plus")
                            mode = "CHANGE_ACTION_MODE_PLUS"
                        }

                        if (mode == "NONE" && data.axes[2] < -0.75 && data.handedness == "left") {
                            console.log("change action mode plus")
                            mode = "CHANGE_ACTION_MODE_MINUS"
                        }

                        if (mode == "CHANGE_ACTION_MODE_PLUS" && data.axes[2] < 0.05 && data.handedness == "left") {
                            //change mode
                            ACTION_MODE = (ACTION_MODE + 1) % NUM_ACTION_MODES

                            console.log('setting gui', ACTION_MODE)
                            set_gui_text(controller, ACTION_MODES[ACTION_MODE])

                            console.log("changed action mode", ACTION_MODE)
                            mode = "NONE"
                        }

                        if (mode == "CHANGE_ACTION_MODE_MINUS" && data.axes[2] > -0.05 && data.handedness == "left") {
                            //change mode
                            ACTION_MODE = (ACTION_MODE - 1 + NUM_ACTION_MODES) % NUM_ACTION_MODES

                            console.log('setting gui', ACTION_MODE)
                            set_gui_text(controller, ACTION_MODES[ACTION_MODE])

                            console.log("changed action mode", ACTION_MODE)
                            mode = "NONE"
                        }

                        //using right touchpad
                        if (mode == "NONE" && data.axes[1] > 0.75 && data.handedness == "right") {
                            console.log("change action mode plus")
                            mode = "CHANGE_ACTION_MODE_PLUS_r1"
                        }

                        if (mode == "NONE" && data.axes[1] < -0.75 && data.handedness == "right") {
                            console.log("change action mode plus")
                            mode = "CHANGE_ACTION_MODE_MINUS_r1"
                        }

                        if (mode == "CHANGE_ACTION_MODE_PLUS_r1" && data.axes[1] < 0.05 && data.handedness == "right") {
                            //change mode
                            ACTION_MODE = (ACTION_MODE + 1) % NUM_ACTION_MODES

                            console.log('setting gui', ACTION_MODE)
                            set_gui_text(controller, ACTION_MODES[ACTION_MODE])

                            console.log("changed action mode", ACTION_MODE)
                            mode = "NONE"
                        }

                        if (mode == "CHANGE_ACTION_MODE_MINUS_r1" && data.axes[1] > -0.05 && data.handedness == "right") {
                            //change mode
                            ACTION_MODE = (ACTION_MODE - 1 + NUM_ACTION_MODES) % NUM_ACTION_MODES

                            console.log('setting gui', ACTION_MODE)
                            set_gui_text(controller, ACTION_MODES[ACTION_MODE])

                            console.log("changed action mode", ACTION_MODE)
                            mode = "NONE"
                        }




                        //button 4 (left a) will change action mode


                        if (data.handedness == "left" && data.buttons[4] && lhs_mode == "NONE") {
                            ACTION_MODE = (ACTION_MODE + 1) % NUM_ACTION_MODES

                            console.log('setting gui', ACTION_MODE)
                            set_gui_text(controller, ACTION_MODES[ACTION_MODE])

                            lhs_mode = "CHANGE_ACTION_MODE"
                        }

                        if (data.handedness == "left" && data.buttons[4] == 0 && lhs_mode == "CHANGE_ACTION_MODE") {
                            console.log("updated mode", ACTION_MODE)
                            lhs_mode = "NONE"
                        }





                        //button 4 (right A) will start recording
                        if (data.handedness == "right" && data.buttons[4] && mode == "NONE") {

                            console.log("a button pushed", ACTION_MODE, ACTION_MODES[ACTION_MODE])


                            if (ACTION_MODES[ACTION_MODE] == "create") {
                                console.log("start recording")
                                startRecording()
                                mode = "RECORDING"
                            }


                            if (ACTION_MODES[ACTION_MODE] == "delete") {
                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("deleting")
                                    mode = "DELETING"
                                } else {
                                    console.log("nothing to delete!")
                                }
                            }


                            if (ACTION_MODES[ACTION_MODE] == "recreate") {
                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("recreating")
                                    mode = "RECREATING"
                                } else {
                                    console.log("nothing to recreate!")
                                }
                            }


                            if (ACTION_MODES[ACTION_MODE] == "duplicate") {
                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("duplicating")
                                    mode = "DUPLICATING"
                                } else {
                                    console.log("nothing to duplicate!")
                                }
                            }

                            if (ACTION_MODES[ACTION_MODE] == "aspect ratio") {
                                which_aspect_ratio = (which_aspect_ratio + 1) % num_aspect_ratios
                                aspect_ratio = aspect_ratios[which_aspect_ratio]

                                console.log("new aspect ratio", aspect_ratio)

                                set_gui_text(controller, aspect_ratio)


                                //todo: display this somewhere

                                mode = "CHANGE_ASPECT_RATIO"

                            }



                            if (ACTION_MODES[ACTION_MODE] == "object type") {
                                CURRENT_OBJECT_TYPE = (CURRENT_OBJECT_TYPE + 1) % NUM_OBJECT_TYPES
                                OBJECT_TYPE = OBJECT_TYPES[CURRENT_OBJECT_TYPE]

                                console.log("object type", OBJECT_TYPE)

                                set_gui_text(controller, OBJECT_TYPE)


                                //todo: display this somewhere

                                mode = "CHANGE_OBJECT_TYPE"

                            }

                            if (ACTION_MODES[ACTION_MODE] == "move") {

                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("moving")
                                    objectToMove = intersects_mesh[0].object
                                    console.log("about to die", controller, objectToMove)
                                    controller.attach(objectToMove);
                                    mode = "MOVE_OBJECT"
                                } else {
                                    console.log("nothing to move!")
                                }

                            }

                            if (ACTION_MODES[ACTION_MODE] == "resize") {

                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("scaling")
                                    objectToMove = intersects_mesh[0].object

                                    console.log("about to die", objectToMove, controller1, controller2)

                                    startingObjectScale = objectToMove.scale.x
                                    startingControllerDist = controller1.position.clone().sub(controller2.position).length()
                                    mode = "RESIZE_OBJECT"
                                } else {
                                    console.log("nothing to resize!")
                                }

                            }



                            if (ACTION_MODES[ACTION_MODE] == "audio") {

                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    console.log("audio")
                                    objectToMove = intersects_mesh[0].object
                                    console.log("about to die", controller, objectToMove)
                                    mode = "ADD_AUDIO"
                                } else {
                                    console.log("nothing to add audio to!")
                                }



                            }

                        } else {
                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "RECORDING") {

                                let objectType = OBJECT_TYPE

                                console.log("stop recording", objectType)

                                stopRecording(nextCubePosition, nextCubeRotation, objectType)
                                mode = "NONE"
                            }

                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "DELETING") {

                                //check if we want to delete
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    //displayCaption(intersects_mesh[0].object)
                                    let objectToDelete = intersects_mesh[0].object
                                    //delete object
                                    let indexToDelete = allMeshes.indexOf(objectToDelete)
                                    if (indexToDelete >= 0) {
                                        allMeshes.splice(indexToDelete, 1)
                                        if (objectToDelete.userData["caption"]) {
                                            scene.remove(objectToDelete.userData["caption"])
                                            objectToDelete.userData["caption"] = null
                                        }
                                        scene.remove(objectToDelete)
                                        //do we not remove from savedata?
                                        let key = objectToDelete.userData["key"]
                                        console.log("deleting object with key", key)
                                        let t = 0
                                        if (key) {

                                            //delete from database
                                            let gridX = Math.floor(objectToDelete.position.x / gridSize)
                                            let gridZ = Math.floor(objectToDelete.position.z / gridSize)


                                            deleteThisObject({
                                                "world": WORLD,
                                                "user": USER,
                                                "gridX": gridX,
                                                "gridZ": gridZ,
                                                "key": key,
                                                "nonce": 0
                                            })


                                            //find in saveData.objects
                                            for (var j in saveData.objects) {
                                                if (saveData.objects[j]["key"] == key) {
                                                    console.log("removing object ", j, "with key", key, "from saveData")
                                                    saveData.objects.splice(j, 1)
                                                    t = 1
                                                    break
                                                }
                                            }
                                            if (t == 0) {
                                                console.log("key", key, "not found!")
                                            } else {
                                                console.log("saving")
                                                if (savePath != "NONE") {
                                                    doSave()
                                                }
                                            }

                                        }
                                    } else {
                                        console.log("this should never happen!")
                                    }
                                    console.log("deleted")
                                } else {
                                    console.log("not deleting")
                                }
                                mode = "NONE"
                            }


                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "RECREATING") {

                                //check if we want to RECREATe
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    //displayCaption(intersects_mesh[0].object)
                                    let objectToDelete = intersects_mesh[0].object
                                    //todo: implement recreating
                                    recreateObject(objectToDelete)
                                    console.log("recreating")
                                } else {
                                    console.log("not recreating")
                                }
                                mode = "NONE"
                            }



                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "DUPLICATING") {

                                //check if we want to RECREATe
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    //displayCaption(intersects_mesh[0].object)
                                    let objectToDelete = intersects_mesh[0].object
                                    //todo: implement recreating
                                    duplicateObject(objectToDelete)
                                    console.log("duplicating")
                                } else {
                                    console.log("not dupliating")
                                }
                                mode = "NONE"
                            }

                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "CHANGE_ASPECT_RATIO") {

                                set_gui_text(controller, "")

                                console.log("changed aspect ratio")
                                mode = "NONE"

                            }

                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "CHANGE_OBJECT_TYPE") {

                                set_gui_text(controller, "")

                                console.log("changed objet type")
                                mode = "NONE"

                            }

                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "MOVE_OBJECT") {

                                scene.attach(objectToMove)

                                //todo save new position and rotation
                                let key = objectToMove.userData["key"]
                                console.log("saving new position of object with key", key)
                                let t = 0
                                let thisObject
                                if (key) {
                                    //find in saveData.objects
                                    for (var j in saveData.objects) {
                                        if (saveData.objects[j]["key"] == key) {
                                            saveData.objects[j]["xyz"] = [objectToMove.position.x, objectToMove.position.y, objectToMove.position.z],
                                                saveData.objects[j]["rotation"] = objectToMove.rotation.y,
                                                saveData.objects[j]["rotation_xyz"] = [objectToMove.rotation.x, objectToMove.rotation.y, objectToMove.rotation.z],
                                                t = 1
                                            thisObject = saveData.objects[j]
                                            break
                                        }
                                    }
                                    if (t == 0) {
                                        console.log("key", key, "not found!")




                                    } else {
                                        console.log("saving")
                                        if (savePath != "NONE") {
                                            doSave()

                                            //save object to dataset
                                            saveObjectToDataset(thisObject)
                                        }
                                    }



                                }

                                console.log("moved object")
                                mode = "NONE"

                            }

                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "RESIZE_OBJECT") {

                                let endingControllerDist = controller1.position.clone().sub(controller2.position).length()
                                let endingObjectScale = startingObjectScale * endingControllerDist / startingControllerDist

                                objectToMove.scale.set(endingObjectScale, endingObjectScale, endingObjectScale)

                                //todo save new position and rotation
                                let key = objectToMove.userData["key"]
                                console.log("saving new position of object with key", key)
                                let t = 0
                                let thisObject
                                if (key) {
                                    //find in saveData.objects
                                    for (var j in saveData.objects) {
                                        if (saveData.objects[j]["key"] == key) {
                                            saveData.objects[j]["xyz"] = [objectToMove.position.x, objectToMove.position.y, objectToMove.position.z],
                                                saveData.objects[j]["rotation"] = objectToMove.rotation.y,
                                                saveData.objects[j]["rotation_xyz"] = [objectToMove.rotation.x, objectToMove.rotation.y, objectToMove.rotation.z],
                                                saveData.objects[j]["scale"] = [objectToMove.scale.x, objectToMove.scale.y, objectToMove.scale.z],
                                                t = 1
                                            thisObject = saveData.objects[j]
                                            break
                                        }
                                    }
                                    if (t == 0) {
                                        console.log("key", key, "not found!")
                                    } else {
                                        console.log("saving")
                                        if (savePath != "NONE") {
                                            doSave()

                                            //save object to dataset
                                            saveObjectToDataset(thisObject)

                                        }
                                    }

                                }

                                console.log("moved object")
                                mode = "NONE"

                            }





                            if (data.handedness == "right" && data.buttons[4] == 0 && mode == "ADD_AUDIO") {

                                //check if we want to RECREATe
                                tempMatrix.identity().extractRotation(controller.matrixWorld);
                                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                                raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);
                                //check for intersects with meshs
                                const intersects_mesh = raycaster.intersectObjects(allMeshes);
                                if (intersects_mesh.length > 0) {
                                    //displayCaption(intersects_mesh[0].object)
                                    let objectToDelete = intersects_mesh[0].object
                                    //todo: implement recreating
                                    addAudio(objectToDelete)
                                    console.log("adding audio")
                                } else {
                                    console.log("not adding audio")
                                }
                                mode = "NONE"
                            }


                            //button map
                            ///???? = B
                            //4 == A
                            //3 = ?grip
                            //2=touchpad
                            //1 = joystick
                            //0 = trigger


                            ///store this frames data to compate with in the next frame
                            prevGamePads.set(source, data);
                        }
                    }
                }
            }
        }

        function isIterable(obj) {  //function to check if object is iterable
            // checks for null and undefined
            if (obj == null) {
                return false;
            }
            return typeof obj[Symbol.iterator] === "function";
        }


        var mediaRecorder
        var recordedChunks


        var onFail = function (e) {
            console.log('Rejected!', e);
        };

        var onSuccess = function (stream) {
            recordedChunks = [];

            var options = { mimeType: 'audio/webm' };
            mediaRecorder = new MediaRecorder(stream, options);
            mediaRecorder.ondataavailable = handleDataAvailable;
            mediaRecorder.start();
            function handleDataAvailable(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                } else {
                    // ...
                }
            }
        }

        window.URL = window.URL || window.webkitURL;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

        var recorder;
        var audio = document.querySelector('audio');


        let nextCubePosition;
        let nextCubeRotation;
        let placeholderCube;

        function startRecording() {
            if (navigator.getUserMedia) {
                navigator.getUserMedia({ audio: true }, onSuccess, onFail);
            } else {
                console.log('navigator.getUserMedia not present');
            }
            //camera position?
            const position = new THREE.Vector3();
            const rotation = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            // the following line extracts the position, rotation and scale in world space
            camera.matrixWorld.decompose(position, rotation, scale);
            const euler = new THREE.Euler();
            euler.setFromQuaternion(rotation, "YZX")
            let r = euler.y
            //use this to place object
            nextCubePosition = new THREE.Vector3().copy(position);
            //nextCubePosition.y = 1
            //nextCubePosition.y -= 0.5


            nextCubePosition.x -= 2 * Math.sin(r)
            nextCubePosition.z -= 2 * Math.cos(r)

            nextCubePosition.y = getFloorHeight(nextCubePosition.x,nextCubePosition.z)

            nextCubeRotation = r

            placeholderCube = addPlaceholder(nextCubePosition, nextCubeRotation, "#00ff00");


        }

        async function play(nextCubePosition, nextCubeRotation, objectType) {

            let thisAspectRatio = aspect_ratio

            var superBuffer = new Blob(recordedChunks);
            audio.src =
                window.URL.createObjectURL(superBuffer);

            let placeholder = addPlaceholder(nextCubePosition, nextCubeRotation, "#aaaaaa", { 'r': 1, "g": 0, "b": 0 }, 30);
            console.log("added placeholder")

            let width = baseSize
            let height = baseSize

            if (objectType == "NPC") {
                thisAspectRatio = "portrait"
            }

            if (["Mob", "Boss", "Tree", "Plant", "Fish", "Building"].includes(objectType)) {
                thisAspectRatio = "square"
            }

            if (thisAspectRatio == "portrait") {
                if (baseSize == 512) {
                    height = 768
                } else {
                    height = 1152
                }


            } else if (thisAspectRatio == "landscape") {
                if (baseSize == 512) {
                    width = 768
                } else {
                    width = 1152
                }
            }


            //send blob to server
            let fd = new FormData();


            fd.set("width", width)
            fd.set("height", height)
            fd.set("objectType", objectType)


            fd.append("audio_data", superBuffer);

            //fetch url from /tts endpoint
            let response = await fetch("/putAudio", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()

            console.log(data)

            let key = "KEY" + Math.random() + "_" + Math.random()
            let userCreated = true
            add3dImage(data, nextCubePosition, nextCubeRotation, true, thisAspectRatio, key, null, objectType, userCreated)
            scene.remove(placeholder)

        }

        function hideDistanceObjects(cameraPosition) {
            for (var mesh of allMeshes) {
                let d = cameraPosition.clone().sub(mesh.position).length()
                if (d < far) {
                    mesh.visible = true
                } else {
                    mesh.visible = false
                }

            }
        }

        //convert from [-1,1] to a color
        function heightToColor(h) {
            //convert to 0,1
            let h01 = (h + 1) / 2
            if (h01 < seaLevel) {
                let v = h01 / seaLevel
                return [0, 0, v]
            } else {
                let v = (h01 - seaLevel) / (1 - seaLevel)
                return [v, 1, v]
            }
        }


        async function getFloorTile(gridX, gridZ) {

            //send prompt to server
            let fd = new FormData();
            fd.set("x0", gridX * terrainScale)
            fd.set("x1", (gridX + 1) * terrainScale)
            fd.set("y0", gridZ * terrainScale)
            fd.set("y1", (gridZ + 1) * terrainScale)
            fd.set("k", 11)

            //fetch url from /tts endpoint
            let response = await fetch("/noise2d", {
                body: fd,
                method: "POST"
            })

            let data = await response.json()

            const geometry = new THREE.BufferGeometry();

            const indices = [];

            const vertices = [];
            const normals = [];
            const colors = [];
            const uvs = [];

            const size = gridSize;
            const segments = 10;

            const halfSize = size / 2;
            const segmentSize = size / segments;

            // generate vertices, normals and color data for a simple grid geometry

            for (let i = 0; i <= segments; i++) {

                //const z = (i * segmentSize) - halfSize;
                const z = (i * segmentSize);

                for (let j = 0; j <= segments; j++) {

                    //const x = (j * segmentSize) - halfSize;
                    const x = (j * segmentSize);

                    const y = data[i][j] * terrainScaleY

                    vertices.push(x, y, z);
                    normals.push(0, 0, 1);
                    uvs.push(i / segments, j / segments)

                    //const r = (x / size) + 0.5;
                    //const g = (y / size) + 0.5;
                    //colors.push(r, g, 1);
                    let color = heightToColor(data[i][j])
                    colors.push(color[0], color[1], color[2])

                }

            }

            // generate indices (data for element array buffer)

            for (let i = 0; i < segments; i++) {

                for (let j = 0; j < segments; j++) {

                    const a = i * (segments + 1) + (j + 1);
                    const b = i * (segments + 1) + j;
                    const c = (i + 1) * (segments + 1) + j;
                    const d = (i + 1) * (segments + 1) + (j + 1);

                    // generate two faces (triangles) per iteration

                    indices.push(a, b, d); // face one
                    indices.push(b, c, d); // face two

                }

            }

            //

            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));


            const material = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide,
                vertexColors: true
            });

            material.bumpMap = floorNormals
            material.bumpScale = 0.01

            let mesh = new THREE.Mesh(geometry, material);

            mesh.position.set(gridX * gridSize, 0, gridZ * gridSize)

            scene.add(mesh);

            return mesh
        }

        async function generateFloorTiles(position) {


            let _gridX = Math.floor(position.x / gridSize)
            let _gridZ = Math.floor(position.z / gridSize)

            for (let i = -bgGenRange_floor; i < bgGenRange_floor + 1; i++) {
                for (let j = -bgGenRange_floor; j < bgGenRange_floor + 1; j++) {

                    let gridX = _gridX + i
                    let gridZ = _gridZ + j

                    let gridKey = `${gridX}_${gridZ}`
                    if (gridKey in floorTiles) {
                        //do nothing
                    } else {
                        let tile = await getFloorTile(gridX, gridZ)
                        //console.log("added tile", gridX, gridZ, tile)

                        floorTiles[gridKey] = tile
                        floorTiles_list.push(tile)
                    }
                }
            }
        }

        function getFloorHeight(x, z) {

            raycaster.ray.origin.set(x, 999, z)
            raycaster.ray.direction.set(0, -1, 0)

            //const intersects = raycaster.intersectObjects([floor]);
            const intersects = raycaster.intersectObjects(floorTiles_list);

            if (intersects.length > 0) {

                INTERSECTION = intersects[0].point;
                return INTERSECTION.y

            } else {
                console.log("Error, floor not found!")
                return 0
            }


        }

        async function generateBackgroundObjects(position) {
            let _gridX = Math.floor(position.x / gridSize)
            let _gridZ = Math.floor(position.z / gridSize)

            for (let i = -bgGenRange; i < bgGenRange + 1; i++) {
                for (let j = -bgGenRange; j < bgGenRange + 1; j++) {

                    let gridX = _gridX + i
                    let gridZ = _gridZ + j

                    let gridKey = `${gridX}_${gridZ}`
                    if (gridKey in gridToMeshes) {
                        //do nothing
                    } else {
                        console.log("Adding bg object", gridX, gridZ)
                        gridToMeshes[gridKey] = []
                        //something needs to go here
                        let x = (gridX + Math.random()) * gridSize
                        let z = (gridZ + Math.random()) * gridSize
                        //let y = getFloorHeight(x, z) + 0.5
                        let y = getFloorHeight(x, z)

                        let nextCubePosition = new THREE.Vector3(x, y, z)
                        let nextCubeRotation = Math.random() * 2 * Math.PI
                        let placeholder = addPlaceholder(nextCubePosition, nextCubeRotation, "#aaaaaa", { 'r': 1, "g": 0, "b": 0 }, 30);


                        let fd = new FormData();
                        fd.set("x", x / gridSize * terrainScale)
                        fd.set("y", z / gridSize * terrainScale)//gah!  noise uses units of x,y but threejs uses coordinates of x,z (y is up)
                        fd.set("world", WORLD)
                        fd.set("user", USER)

                        //fetch url from /tts endpoint
                        let response = await fetch("/getBackgroundObject", {
                            body: fd,
                            method: "POST"
                        })
                        let data = await response.json()

                        console.log(data)

                        let aspectRatio = data["aspectRatio"]
                        let objectType = data["objectType"]

                        let key = "KEY" + Math.random() + "_" + Math.random()
                        let userCreated = false
                        add3dImage(data, nextCubePosition, nextCubeRotation, true, aspectRatio, key, null, objectType, userCreated)
                        scene.remove(placeholder)
                    }

                }
            }
        }

        async function recreateObject(objectToRecreate) {

            //first let's find the save data
            let key = objectToRecreate.userData["key"]

            let prompt = objectToRecreate.userData["prompt"]
            let thisAspectRatio = objectToRecreate.userData["aspect_ratio"]
            let nextCubePosition = objectToRecreate.position
            let nextCubeRotation = objectToRecreate.rotation.y
            let nextCubeRotation_xyz = [objectToRecreate.rotation.x, objectToRecreate.rotation.y, objectToRecreate.rotation.z]
            let objectType = objectToRecreate.userData["objectType"]

            nextCubePosition.y -= objectToRecreate.userData["meshSize"].y/2



            let placeholder = addPlaceholder(nextCubePosition, nextCubeRotation, "#aaaaaa", { 'r': 1, "g": 0, "b": 0 }, 30);

            //send prompt to server
            let fd = new FormData();
            fd.set("prompt", prompt)
            if (thisAspectRatio == "portrait") {
                fd.set("height", 768)
            } else if (thisAspectRatio == "landscape") {
                fd.set("width", 768)
            }

            fd.set("objectType", objectType)

            //fetch url from /tts endpoint
            let response = await fetch("/genPrompt", {
                body: fd,
                method: "POST"
            })

            if (response.status !== 200) {
                // You can do your error handling here
                console.log("Failed recreate")
                return
            }


            let data = await response.json()

            console.log(data)
            objectType = data["objectType"]


            let newKey = "KEY" + Math.random() + "_" + Math.random()
            let userCreated = true
            add3dImage(data, nextCubePosition, nextCubeRotation, true, thisAspectRatio, newKey, nextCubeRotation_xyz, objectType, userCreated)


            console.log("removing object", objectToRecreate)
            let indexToDelete = allMeshes.indexOf(objectToRecreate)
            if (indexToDelete >= 0) {

                //delete caption
                if (objectToRecreate.userData["caption"]) {
                    scene.remove(objectToRecreate.userData["caption"])
                    objectToRecreate.userData["caption"] = null
                }
                scene.remove(objectToRecreate)



                allMeshes.splice(indexToDelete, 1)
            } else {
                console.log("error, could not remove object!")
            }

            //I have to remove it from all objects
            console.log("removing placeholder")
            scene.remove(placeholder)

            console.log("delete save data for old object", key)
            let t = 0
            let objectToDelete
            if (key) {
                //find in saveData.objects
                for (var j in saveData.objects) {
                    if (saveData.objects[j]["key"] == key) {
                        //remove old save data
                        console.log("removing object ", j, "with key", key, "from saveData")
                        objectToDelete = saveData.objects[j]
                        saveData.objects.splice(j, 1)
                        t = 1
                        break
                    }
                }
                if (t == 0) {
                    console.log("key", key, "not found!")
                } else {
                    console.log("saving")
                    if (savePath != "NONE") {
                        doSave()
                        //remove old object from database
                        let gridX = Math.floor(objectToDelete["xyz"][0] / gridSize)
                        let gridZ = Math.floor(objectToDelete["xyz"][2] / gridSize)
                        let key = objectToDelete["key"]
                        deleteThisObject({
                            "world": WORLD,
                            "user": USER,
                            "gridX": gridX,
                            "gridZ": gridZ,
                            "key": key,
                            "nonce": 0
                        })

                    }
                }
            }

        }



        async function duplicateObject(objectToRecreate) {

            //first let's find the save data
            let key = objectToRecreate.userData["key"]

            let prompt = objectToRecreate.userData["prompt"]
            let thisObjectType = objectToRecreate.userData["objectType"]
            let thisAspectRatio = objectToRecreate.userData["aspect_ratio"]
            let nextCubePosition = objectToRecreate.position.clone()
            let nextCubeRotation = objectToRecreate.rotation.y
            let nextCubeRotation_xyz = [objectToRecreate.rotation.x, objectToRecreate.rotation.y, objectToRecreate.rotation.z]


            //get 
            const euler = new THREE.Euler();
            euler.setFromQuaternion(objectToRecreate.quaternion, "YZX")

            //offset postion
            //let offsetAmt = 1
            let offsetAmt=objectToRecreate.userData["meshSize"].x

            if (thisAspectRatio == "landscape") {
                offsetAmt = 1.5
            }
            let offsetAngle = Math.PI / 2
            let offsetX = Math.sin(euler.y + offsetAngle) * offsetAmt
            let offsetZ = Math.cos(euler.y + offsetAngle) * offsetAmt

            nextCubePosition.x += offsetX
            nextCubePosition.z += offsetZ

            //move in local z
            let offsetX2 = Math.sin(euler.y) * objectToRecreate.userData["meshSize"].z/2
            let offsetZ2 = Math.cos(euler.y) * objectToRecreate.userData["meshSize"].z/2

            nextCubePosition.x += offsetX2
            nextCubePosition.z += offsetZ2


            nextCubePosition.y -= objectToRecreate.userData["meshSize"].y/2


            let placeholder = addPlaceholder(nextCubePosition, nextCubeRotation, "#aaaaaa", { 'r': 1, "g": 0, "b": 0 }, 30);

            //send prompt to server
            let fd = new FormData();
            fd.set("prompt", prompt)
            if (thisAspectRatio == "portrait") {
                fd.set("height", 768)
            } else if (thisAspectRatio == "landscape") {
                fd.set("width", 768)
            }

            fd.set("objectType", thisObjectType)

            //fetch url from /tts endpoint
            let response = await fetch("/genPrompt", {
                body: fd,
                method: "POST"
            })

            if (response.status !== 200) {
                // You can do your error handling here
                console.log("Failed recreate")
                return
            }


            let data = await response.json()

            console.log(data)
            let objectType = data["objectType"]


            let newKey = "KEY" + Math.random() + "_" + Math.random()

            let userCreated = true

            add3dImage(data, nextCubePosition, nextCubeRotation, true, thisAspectRatio, newKey, nextCubeRotation_xyz, objectType, userCreated)



            /*
            console.log("removing object", objectToRecreate)
            let indexToDelete = allMeshes.indexOf(objectToRecreate)
            if (indexToDelete >= 0) {
 
                //delete caption
                if (objectToRecreate.userData["caption"]) {
                    scene.remove(objectToRecreate.userData["caption"])
                    objectToRecreate.userData["caption"] = null
                }
                scene.remove(objectToRecreate)
 
                allMeshes.splice(indexToDelete, 1)
            } else {
                console.log("error, could not remove object!")
            }
 
            //I have to remove it from all objects
            
 
            console.log("delete save data for old object", key)
            let t = 0
            if (key) {
                //find in saveData.objects
                for (var j in saveData.objects) {
                    if (saveData.objects[j]["key"] == key) {
                        //remove old save data
                        console.log("removing object ", j, "with key", key, "from saveData")
                        saveData.objects.splice(j, 1)
                        t = 1
                        break
                    }
                }
                if (t == 0) {
                    console.log("key", key, "not found!")
                } else {
                    console.log("saving")
                    if (savePath != "NONE") {
                        doSave()
                    }
                }
            }
            */

            console.log("removing placeholder")
            scene.remove(placeholder)

        }



        async function addAudio(objectToRecreate) {

            //if object has audio, remove it
            if (objectToRecreate.userData["audio"]) {
                console.log("removing audio")
                objectToRecreate.userData["audio"].stop()
                objectToRecreate.remove(objectToRecreate.userData["audio"])
                scene.remove(objectToRecreate.userData["audio"])
                objectToRecreate.userData["audio"] = null

                //remove from save data
                //first let's find the save data
                let key = objectToRecreate.userData["key"]
                console.log("save audio", key)
                let t = 0
                let thisObject
                if (key) {
                    //find in saveData.objects
                    for (var j in saveData.objects) {
                        if (saveData.objects[j]["key"] == key) {
                            //remove old save data
                            console.log("removing audio to object ", j, "with key", key, "from saveData")
                            delete saveData.objects[j]["audioURL"]
                            t = 1
                            thisObject = saveData.objects[j]
                            break
                        }
                    }
                    if (t == 0) {
                        console.log("key", key, "not found!")
                    } else {
                        console.log("saving")
                        if (savePath != "NONE") {
                            doSave()

                            //save object to dataset
                            saveObjectToDataset(thisObject)
                        }
                    }
                }


                return
            }

            //add a placeholder
            let prompt = objectToRecreate.userData["prompt"]
            let thisAspectRatio = objectToRecreate.userData["aspect_ratio"]
            let nextCubePosition = objectToRecreate.position
            let nextCubeRotation = objectToRecreate.rotation.y
            let nextCubeRotation_xyz = [objectToRecreate.rotation.x, objectToRecreate.rotation.y, objectToRecreate.rotation.z]

            let placeholder = addPlaceholder(nextCubePosition, nextCubeRotation, "#aaaaaa", { 'r': 1, "g": 0, "b": 0 }, 30);

            //get audio
            //send prompt to server
            let fd = new FormData();
            fd.set("prompt", prompt)

            //fetch url from /tts endpoint
            let response = await fetch("/genAudio", {
                body: fd,
                method: "POST"
            })

            if (response.status !== 200) {
                // You can do your error handling here
                console.log("Failed recreate")
                return
            }


            let data = await response.json()

            console.log(data)

            let audioURL = data['url']

            // create an AudioListener and add it to the camera
            const listener = new THREE.AudioListener();
            camera.add(listener);

            // create the PositionalAudio object (passing in the listener)
            const sound = new THREE.PositionalAudio(listener);

            // load a sound and set it as the PositionalAudio object's buffer
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(audioURL, function (buffer) {
                sound.setBuffer(buffer);
                sound.setRefDistance(AUDIO_REF_DIST);
                sound.setLoop(true)
                sound.play();

            });

            //save data
            //first let's find the save data
            let key = objectToRecreate.userData["key"]
            console.log("save audio", key)
            let t = 0
            if (key) {
                //find in saveData.objects
                for (var j in saveData.objects) {
                    if (saveData.objects[j]["key"] == key) {
                        //remove old save data
                        console.log("adding audio to object ", j, "with key", key, "from saveData")
                        saveData.objects[j]["audioURL"] = audioURL
                        t = 1
                        break
                    }
                }
                if (t == 0) {
                    console.log("key", key, "not found!")
                } else {
                    console.log("saving")
                    if (savePath != "NONE") {
                        doSave()
                    }
                }
            }




            //add sound to object
            objectToRecreate.userData["audio"] = sound

            objectToRecreate.add(sound)

            //delete placeholder
            scene.remove(placeholder)

        }

        function stopRecording(nextCubePosition, nextCubeRotation, objectType) {

            if (!mediaRecorder) return

            mediaRecorder.stop();

            scene.remove(placeholderCube)

            function doPlay() {
                play(nextCubePosition, nextCubeRotation, objectType)
            }
            setTimeout(doPlay, 0.1)

        }

        async function saveObjectToDataset(someObject) {

            let fd = new FormData();
            fd.append("savePath", savePath);
            fd.append("saveData", JSON.stringify(someObject));

            //fetch url from /tts endpoint
            let response = await fetch("/saveObject", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()
            console.log(data)

        }


        async function deleteThisObject(someObject) {

            let fd = new FormData();
            fd.append("saveData", JSON.stringify(someObject));

            //fetch url from /tts endpoint
            let response = await fetch("/deleteObject", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()
            console.log(data)
        }

        async function updateWorld(position) {
            await generateFloorTiles(position)
            await loadGridObjects(position)
            //await generateBackgroundObjects(position)
        }

        async function loadGridObjects(position) {

            let gridX = Math.floor(position.x / gridSize)
            let gridZ = Math.floor(position.z / gridSize)

            for (var i = -bgGenRange_floor; i <= bgGenRange_floor; i++) {
                for (var j = -bgGenRange_floor; j <= bgGenRange_floor; j++) {
                    await loadTheseGridObjects(gridX + i, gridZ + j)

                }
            }

        }

        async function loadTheseGridObjects(gridX, gridZ) {

            let gridKey = `${gridX}_${gridZ}`

            //don't reload every time
            if (gridLoaded[gridKey]) {
                return
            }


            let fd = new FormData();
            fd.append("user", USER);
            fd.append("world", WORLD);
            fd.append("gridX", gridX);
            fd.append("gridZ", gridZ);

            //fetch url from /tts endpoint
            let response = await fetch("/loadObjects", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()


            //add objects if not already added

            //console.log(data)
            if (!data) return

            for (var _object of data) {

                let object = JSON.parse(_object["data"])

                console.log("adding object", object["name"])

                let t = 0
                if (gridKey in gridToMeshes) {
                    for (var gridObject of gridToMeshes[gridKey]) {
                        if (gridObject.userData["key"] == object["key"]) {
                            t = 1
                            break
                        }
                    }
                }

                if (t == 1) {
                    continue
                } else {


                    let position = new THREE.Vector3(object.xyz[0], object.xyz[1], object.xyz[2])
                    let rotation = object.rotation
                    let d = {
                        "name": object.name,
                        "img": object.map,
                        "depth": object.disp,
                        "edge": object.edge,
                        "bg": object.bg,
                        "objectType": object.objectType
                    }
                    let thisAspectRatio = object.aspect_ratio
                    let key = object.key
                    console.log("adding object", d, position, rotation, thisAspectRatio, key)

                    let userCreated = object.userCreated
                    let mesh = add3dImage(d, position, rotation, false, thisAspectRatio, key, object.rotation_xyz, object.objectType, userCreated)
                    if ("scale" in object) {
                        mesh.scale.set(object.scale[0], object.scale[1], object.scale[2])
                    }

                    //add audio
                    if (object["audioURL"]) {

                        let audioURL = object["audioURL"]

                        if (audioReady) {

                            // create an AudioListener and add it to the camera
                            const listener = new THREE.AudioListener();
                            camera.add(listener);

                            // create the PositionalAudio object (passing in the listener)
                            const sound = new THREE.PositionalAudio(listener);

                            // load a sound and set it as the PositionalAudio object's buffer
                            const audioLoader = new THREE.AudioLoader();
                            audioLoader.load(audioURL, function (buffer) {
                                sound.setBuffer(buffer);
                                sound.setRefDistance(AUDIO_REF_DIST);
                                sound.setLoop(true)
                                sound.play();

                            });

                            //attach to mesth

                            //add sound to object
                            mesh.userData["audio"] = sound
                            mesh.add(sound)

                        } else {
                            audioTodo.push([mesh, audioURL])
                        }

                    }

                    saveData.objects.push(object)


                }
            }

            gridLoaded[gridKey] = true


        }


        function add3dImage(data, position, rotation, saveThisObject, thisAspectRatio, key, rotation_xyz, objectType, userCreated) {
            let imgPath = "../samples/" + data["img"]
            let dPath = "../samples/" + data["depth"]

            const textureLoader = new THREE.TextureLoader();
            const colorMap = textureLoader.load(imgPath);
            const displacementMap = textureLoader.load(dPath);


            let ePath = "../samples/" + data["edge"]
            let edgeMap = textureLoader.load(ePath);


            let bgPath = "../samples/" + data["bg"]
            let bgMap = textureLoader.load(bgPath);

            let displacementBias = -0.5
            let displacementScale = 1.0



            let material;
            if (edgeMap) {
                material = new THREE.MeshStandardMaterial({
                    map: colorMap,
                    displacementMap: displacementMap,
                    displacementScale: displacementScale,
                    displacementBias: displacementBias, // from original model
                    alphaMap: edgeMap,
                    transparent: true,
                    side: THREE.DoubleSide
                });
            } else {
                material = new THREE.MeshStandardMaterial({
                    map: colorMap,
                    displacementMap: displacementMap,
                    displacementScale: displacementScale,
                    displacementBias: displacementBias, // from original model
                    side: THREE.DoubleSide
                });
            }

            if (objectType == "Building") {
                let displacementScale = 0.1
                let displacementBias = 0

                material = new THREE.MeshStandardMaterial({
                    map: colorMap,
                    displacementMap: displacementMap,
                    displacementScale: displacementScale,
                    displacementBias: displacementBias, // from original model
                    side: THREE.DoubleSide
                });
            }

            //these should all basically be cutouts
            if (["Object", "NPC", "Boss", "Mob", "Fish", "Tree", "Plant"].includes(objectType)) {
                material = new THREE.MeshStandardMaterial({
                    map: colorMap,
                    displacementMap: displacementMap,
                    displacementScale: displacementScale,
                    displacementBias: displacementBias, // from original model
                    alphaMap: bgMap,
                    transparent: true,
                    side: THREE.DoubleSide
                });
            }

            //back compatability
            if (!thisAspectRatio) {
                thisAspectRatio = "square"
            }

            //let geometry = new THREE.BoxGeometry(1, 1, 1, 100, 100, 100);
            let geometry
            if (thisAspectRatio == "portrait") {
                geometry = new THREE.PlaneGeometry(1, 1.5, 100, 100);
            } else if (thisAspectRatio == "landscape") {
                geometry = new THREE.PlaneGeometry(1.5, 1, 100, 100);
            } else {
                //square
                geometry = new THREE.PlaneGeometry(1, 1, 100, 100);
            }

            //building
            if (objectType == "Building") {
                geometry = new THREE.BoxGeometry(5, 5, 5, 100, 100, 100);
            }

            if (objectType == "Tree") {
                geometry = new THREE.PlaneGeometry(3, 3, 100, 100);
            }


            if (objectType == "Boss") {
                geometry = new THREE.PlaneGeometry(3, 3, 100, 100);
            }

            let mesh = new THREE.Mesh(geometry, material);

            console.log("adding mesh", mesh)

            scene.add(mesh);

            //get size and use to update position
            const box = new THREE.Box3();
            mesh.geometry.computeBoundingBox();
            box.copy( mesh.geometry.boundingBox ).applyMatrix4( mesh.matrixWorld );
            let meshSize= new THREE.Vector3()
            box.getSize(meshSize)

            let yOffset=meshSize.y/2
            let xOffset= -Math.sin(rotation)*meshSize.z/2
            let zOffset= -Math.cos(rotation)*meshSize.z/2



            //mesh.rotation.y = rotation - Math.PI / 2;
            mesh.rotation.y = rotation;
            mesh.position.copy(position);
            mesh.position.x+=xOffset
            mesh.position.y+=yOffset
            mesh.position.z+=zOffset

            if (rotation_xyz) {
                mesh.rotation.x = rotation_xyz[0];
                mesh.rotation.y = rotation_xyz[1];
                mesh.rotation.z = rotation_xyz[2];
            }

            //save prompt to userdata
            mesh.userData["prompt"] = data["name"]
            mesh.userData["key"] = key
            mesh.userData["aspect_ratio"] = thisAspectRatio
            mesh.userData["objectType"] = objectType

            mesh.userData["meshSize"] = meshSize

            //store mesh in allMeshes
            allMeshes.push(mesh)

            //add mesh to grid
            let gridX = Math.floor(mesh.position.x / gridSize)
            let gridZ = Math.floor(mesh.position.z / gridSize)
            let gridKey = `${gridX}_${gridZ}`
            if (gridKey in gridToMeshes) {
                gridToMeshes[gridKey].push(mesh)
            } else {
                gridToMeshes[gridKey] = [mesh]
            }


            if (saveThisObject) {

                let thisObject = {
                    "gridX": gridX,
                    "gridZ": gridZ,
                    "user": USER,
                    "world": WORLD,
                    "key": key,
                    "nonce": 0,
                    "name": data["name"],
                    "map": data["img"],
                    "disp": data["depth"],
                    "edge": data["edge"],
                    "bg": data["bg"],
                    "xyz": [mesh.position.x - xOffset, mesh.position.y -yOffset, mesh.position.z - zOffset],
                    "rotation": mesh.rotation.y,
                    "rotation_xyz": [mesh.rotation.x, mesh.rotation.y, mesh.rotation.z],
                    "aspect_ratio": thisAspectRatio,
                    "objectType": objectType,
                    "userCreated": userCreated,
                }

                //save object to dataset
                saveObjectToDataset(thisObject)

                saveData.objects.push(thisObject)

                if (savePath != "NONE") {
                    doSave()
                }



            }


            return mesh
        }

        function addPlaceholder(position, rotation, color, rgb2, time) {
            let material = new THREE.MeshStandardMaterial({
                color: color,
                side: THREE.DoubleSide
            });



            let geometry = new THREE.BoxGeometry(1, 1, 1, 100, 100, 100);
            let mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);


            if (rgb2) {
                new TWEEN.Tween(mesh.material.color).to({ r: rgb2.r, g: rgb2.g, b: rgb2.b }, time * 1000).start()
                //new TWEEN.Tween(mesh.material.color).to({r: 1, g: 0, b: 0 }, 2000).start()
            }

            mesh.position.copy(position);
            mesh.rotation.y = rotation - Math.PI;

            return mesh
        }

        async function doSave() {
            let fd = new FormData();
            fd.append("savePath", savePath);
            fd.append("saveData", JSON.stringify(saveData));

            //fetch url from /tts endpoint
            let response = await fetch("/saveData", {
                body: fd,
                method: "POST"
            })
            let data = await response.json()
            console.log(data)
        }

        async function doLoad(savePath) {
            //fetch url from /tts endpoint
            let response = await fetch("../saveData/" + savePath, {
                headers: {
                    'Cache-Control': 'no-cache'
                }
            })

            let data

            if (response.status !== 200) {
                // You can do your error handling here
                console.log("Failed loading")
                return
            } else {
                // Call the .json() method on your response to get your JSON data
                data = await response.json();
            }


            console.log("Loaded data", data)

            if (!data) return

            for (var object of data.objects) {
                let position = new THREE.Vector3(object.xyz[0], object.xyz[1], object.xyz[2])
                let rotation = object.rotation
                let d = {
                    "name": object.name,
                    "img": object.map,
                    "depth": object.disp,
                    "edge": object.edge,
                    "bg": object.bg,
                    "objectType": object.objecType,
                }

                console.log("about to die", d)

                let thisAspectRatio = object.aspect_ratio
                let key = object.key
                console.log("adding object", d, position, rotation, thisAspectRatio, key)


                let userCreated = object.userCreated


                let mesh = add3dImage(d, position, rotation, false, thisAspectRatio, key, object.rotation_xyz, objectType, userCreated)
                if ("scale" in object) {
                    mesh.scale.set(object.scale[0], object.scale[1], object.scale[2])
                }

                //add audio
                if (object["audioURL"]) {

                    let audioURL = object["audioURL"]

                    if (audioReady) {



                        // create an AudioListener and add it to the camera
                        const listener = new THREE.AudioListener();
                        camera.add(listener);

                        // create the PositionalAudio object (passing in the listener)
                        const sound = new THREE.PositionalAudio(listener);

                        // load a sound and set it as the PositionalAudio object's buffer
                        const audioLoader = new THREE.AudioLoader();
                        audioLoader.load(audioURL, function (buffer) {
                            sound.setBuffer(buffer);
                            sound.setRefDistance(AUDIO_REF_DIST);
                            sound.setLoop(true)
                            sound.play();

                        });

                        //attach to mesth

                        //add sound to object
                        mesh.userData["audio"] = sound
                        mesh.add(sound)

                    } else {
                        audioTodo.push([mesh, audioURL])
                    }

                }


            }


            saveData = data
        }


        function getAudioReady() {

            console.log("trying audio")

            for (var i in audioTodo) {
                let mesh = audioTodo[i][0]
                let audioURL = audioTodo[i][1]

                // create an AudioListener and add it to the camera
                const listener = new THREE.AudioListener();
                camera.add(listener);

                // create the PositionalAudio object (passing in the listener)
                const sound = new THREE.PositionalAudio(listener);

                // load a sound and set it as the PositionalAudio object's buffer
                const audioLoader = new THREE.AudioLoader();
                audioLoader.load(audioURL, function (buffer) {
                    sound.setBuffer(buffer);
                    sound.setRefDistance(AUDIO_REF_DIST);
                    sound.setLoop(true)
                    sound.play();

                });

                //attach to mesth

                //add sound to object
                mesh.userData["audio"] = sound
                mesh.add(sound)
            }


            audioReady = true
        }

        function displayCaption(parentMesh) {


            if (parentMesh.userData["caption"]) {
                parentMesh.remove(parentMesh.userData["caption"])
                parentMesh.userData["caption"] = null
                return
            }


            let prompt = parentMesh.userData["prompt"]




            loader.load('fonts/helvetiker_regular.typeface.json', function (font) {

                const color = 0x000000;
                const scale = 0.002

                const matDark = new THREE.LineBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });

                const matLite = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                const message = prompt;

                const shapes = font.generateShapes(message, 100);

                const geometry = new THREE.ShapeGeometry(shapes);

                geometry.computeBoundingBox();

                const xMid = - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                geometry.translate(xMid, 0, 0);

                // make shape ( N.B. edge view not visible )

                const text = new THREE.Mesh(geometry, matLite);
                parentMesh.add(text);

                //get size
                const box = new THREE.Box3();
                parentMesh.geometry.computeBoundingBox();
                box.copy(parentMesh.geometry.boundingBox).applyMatrix4(parentMesh.matrixWorld);

                //text.position.copy(parentMesh.position)
                text.position.y += 1
                text.position.z = box.max.z - parentMesh.position.z
                //text.rotation.copy(parentMesh.rotation)
                text.scale.set(scale, scale, scale)

                //add to parent user data
                parentMesh.userData["caption"] = text

            });

        }


        function set_gui_text(parentMesh, message) {






            loader.load('fonts/helvetiker_regular.typeface.json', function (font) {


                //move inside to fix race condition?
                if (parentMesh.userData["caption"]) {
                    scene.remove(parentMesh.userData["caption"])
                    parentMesh.userData["caption"] = null //this line isn't strictly necessary
                }



                const color = 0x000000;
                const scale = 0.001

                const matDark = new THREE.LineBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });

                const matLite = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                const shapes = font.generateShapes(message, 100);

                const geometry = new THREE.ShapeGeometry(shapes);

                geometry.computeBoundingBox();

                const xMid = - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                geometry.translate(xMid, 0, 0);

                // make shape ( N.B. edge view not visible )

                const text = new THREE.Mesh(geometry, matLite);
                scene.add(text);

                /*text.position.copy(parentMesh.position)
                text.position.y += 1
                text.rotation.copy(parentMesh.rotation)*/

                text.parent = parentMesh

                text.scale.set(scale, scale, scale)

                //add to parent user data
                parentMesh.userData["caption"] = text

            });

        }

        function doSnapTurn(turnAmount) {
            //fix for roomscale (otherwise snap turn rotates around room center)
            let deltaVector = {
                x: cameraOffsetPosition.x - camera.position.x,
                y: cameraOffsetPosition.y - camera.position.y,
                z: cameraOffsetPosition.z - camera.position.z
            }
            //console.log("rotation counter",rotationCounter,turnAmount,rotationCounter+turnAmount)
            //console.log("camera positon",camera.position)
            //console.log("delta vector",deltaVector,rotationCounter)//delta vector is in the rotatated coordinates :(
            let undeltaVector = {
                x: deltaVector.x * Math.cos(rotationCounter) + deltaVector.z * Math.sin(rotationCounter),
                y: deltaVector.y,
                z: deltaVector.x * -Math.sin(rotationCounter) + deltaVector.z * Math.cos(rotationCounter)
            }
            //console.log("undelta vector",undeltaVector)//undelta vector is in the room coordinates?
            /*let predictedDelta={
                x: undeltaVector.x*Math.cos(rotationCounter) + undeltaVector.z * -Math.sin(rotationCounter),
                y: undeltaVector.y,
                z: undeltaVector.x*Math.sin(rotationCounter) + undeltaVector.z * Math.cos(rotationCounter)                                
            }
            //console.log("predicted delta",predictedDelta)*/
            let predictedNexDelta = {
                x: undeltaVector.x * Math.cos(rotationCounter + turnAmount) + undeltaVector.z * -Math.sin(rotationCounter + turnAmount),
                y: undeltaVector.y,
                z: undeltaVector.x * Math.sin(rotationCounter + turnAmount) + undeltaVector.z * Math.cos(rotationCounter + turnAmount)
            }
            //console.log("predicted next delta",predictedNexDelta)
            let predictedNextCameraPosition = {
                x: cameraOffsetPosition.x - predictedNexDelta.x,
                y: cameraOffsetPosition.y - predictedNexDelta.y,
                z: cameraOffsetPosition.z - predictedNexDelta.z,
            }
            //console.log("predicted next camera position",predictedNextCameraPosition)
            //now let's just adjust by the difference
            cameraOffsetPosition.x = cameraOffsetPosition.x - predictedNextCameraPosition.x + camera.position.x
            cameraOffsetPosition.z = cameraOffsetPosition.z - predictedNextCameraPosition.z + camera.position.z
            //and let's do the transform (sorry this is so ugly)let nullPosition = { x: 0, y: 0, z: 0, w: 1 };
            let nullPosition = { x: 0, y: 0, z: 0, w: 1 };
            let nullRotation = new THREE.Quaternion()
            const offsetPosition = { x: - cameraOffsetPosition.x, y: - cameraOffsetPosition.y, z: - cameraOffsetPosition.z, w: 1 };
            let offsetRotation = new THREE.Quaternion().copy(cameraOffsetRotation);
            const turn = new THREE.Quaternion()
            turn.setFromAxisAngle(new THREE.Vector3(0, 1, 0), turnAmount);
            //offsetRotation=offsetRotation.dot(turn)
            offsetRotation.multiply(turn)
            rotationCounter += turnAmount
            cameraOffsetRotation.copy(offsetRotation)
            const transform = new XRRigidTransform(offsetPosition, nullRotation);
            const doRotate = new XRRigidTransform(nullPosition, offsetRotation);
            const t2 = baseReferenceSpace.getOffsetReferenceSpace(doRotate)
            const t3 = t2.getOffsetReferenceSpace(transform);
            renderer.xr.setReferenceSpace(t3);
        }



    </script>

    <audio controls></audio>


</body>

</html>